#include<iostream>
#include<algorithm>
#include<queue>
#include<vector>
using namespace std;
#define N 2001

priority_queue<int,vector<int>,greater<int>> smallQueue;//greater means the smallest value will be on the top
priority_queue<int,vector<int>,less<int>> bigQueue;//less will let the biggest value on the top
int num[N];

/*
* This problem seems very complicated, actually, after simple analysis, it is easy:
* choose one value from each sequence, and get the sum, then we can have n^m sums
* if we only have one sequence, then we sort the sequence, it is the result.
* if we have two sequences, we have n^2 combinations, and we can get the top n minimum ones
* if we have three sequences, we just need to consider the top n minimum ones (generated by the first 2 sequences) and the coming 3rd sequence data
* if we have ....
* thus, every time, what we have to consider is just the coming n value and the resulting top n minimum ones
* we can use heap or priority queue to implement it
* Combining the above information, we have to maintain two data flow: the coming sequence, and the resulting sequenece from the last several sequences
* we can use two priority queue to represent the two, small Queue to store the generating results from the first k-1 sequence, and use array (num[]) to store the coming
* k-th sequenece. And we also use a temporary queue to store the temporary results which generates num[] and small queue.
*/


int main()
{
	int cases,m,n,x,s;
	cin>>cases;
	while(cases--)
	{
		cin>>m>>n;
		while(!smallQueue.empty())
			smallQueue.pop();
		for (int i=0;i<n;i++)//read the 1st line
		{
			scanf("%d",&x);
			smallQueue.push(x);
		}
		for (int i=1;i<m;i++)//read the next m-1 lines
		{
			for (int j=0;j<n;j++)//read one line
			{
				scanf("%d",num+j);
			}
			//deal with the coming sequence (num[]) and resulted sequence (smallQueue),and store the results into the temp big queue
			while(!smallQueue.empty())
			{
				s=smallQueue.top();
				smallQueue.pop();
				for (int j=0;j<n;j++)
				{
					if (bigQueue.size()<n)
					{
						bigQueue.push(num[j]+s);
					}else if (num[j]+s<bigQueue.top())
					{
						bigQueue.pop();
						bigQueue.push(num[j]+s);
					}
				}
			}
			//transfer data from bigQueue to smallQueue
			while(!bigQueue.empty())
			{
				smallQueue.push(bigQueue.top());
				bigQueue.pop();
			}
		}
		for (int i=0;i<n-1;i++)
		{
			printf("%d ",smallQueue.top());
			smallQueue.pop();
		}
		printf("%d\n",smallQueue.top());
		smallQueue.pop();
	}
	return 0;
}